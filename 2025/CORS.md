# CORS의 등장 배경

## SOP와 CORS
브라우저는 기본적으로 SOP 정책을 따르고 있다. 
**SOP**은 2011년 RFC 6454에서 등장한 보안 정책으로 `같은 출처에서만 리소스를 공유할 수 있다` 라는 규칙을 가진 정책이다. 

그러나 보안도 중요하지만 개발을 하다 보면 기능상 어쩔 수 없이 다른 출처간의 상호작용을 해야하는 케이스가 존재한다.
`다른 출처`의 API 서버를 두거나, `다른 출처`의 외부 리소스를 가져다 쓰는 경우가 있기 때문이다.

이러한 경우를 대비하여 몇가지 예외 조항을 두고, 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했다.
그 중 하나가 `CORS 정책을 지킨 리소스 요청`이다.
즉 CORS라는 정책에 위반되지 않으면 정상적으로 리소스를 요청할 수 있게 해준다는 뜻이다.

## 이런 보안 정책이 등장한 이유?
출처가 다른 두 개의 애플리케이션이 마음대로 소통할 수 있는 환경은 꽤 위험한 환경이기 때문이다.

애초에 클라이언트 어플리케이션, 특히나 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약한 친구라는 사실을 잊지말자. 당장 브라우저의 개발자 도구만 열어도 DOM이 어떻게 작성되어있는지, 어떤 서버와 통신하는지, 리소스의 출처는 어디인지와 같은 각종 정보들을 아무런 제재없이 열람할 수 있다.

최근에는 자바스크립트 소스 코드를 난독화해서 읽기 어렵다고 하지만, 난독화는 어디까지나 난독화일 뿐이지 암호화가 아니다. 그리고 아무리 난독화되어있다고 해도 사람이 바로 이해할 수 없는 정도도 아닌데다가, 소스 코드를 직접 볼 수 있다는 것 자체가 보안적으로 상당히 취약한 부분이다.

이런 상황 속에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 쓱 구경한 후 `CSRF(Cross-Site Request Forgery)`나 `XSS(Cross-Site Scripting)`와 같은 방법을 사용하여 여러분의 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보(토큰이나 쿠키 등)를 탈취하기가 너무나도 쉬워진다.

그래서 개발을 할 때 발생하는 SOP의 불편함을 해소하면서, 보안을 지키기 위해 등장한 것이 CORS이다.

## CORS란?
### CORS(Cross-Origin Resource Sharing)
한국어로 직역하면 '교차 출처 리소스 공유'라고 해석할 수 있다. 여기서 '교차 출처'란 '다른 출처'를 의미한다.
해석을 해보면 Cross-Origin의 Resource를 공유하는 정책이라고 볼 수 있다.

즉, **CORS란 도메인이 다른 서버끼리 리소스를 주고 받을 때 보안을 위해 설정된 정책**이라고 생각하면 된다.

예를 들어, 웹 사이트 A가 API 서버 B에서 데이터를 가져오려 할 때,
API 서버 B에서 CORS 허용 설정이 되어 있지 않으면 웹 브라우저에서 API 접근이 거부될 수 있다.

## Origin
그렇다면 같은 출처와 다른 출처의 구분은 어떻게 할까?
그 전에 Origin(출처)에 대해 짚고 넘어가야 한다.

![image](/image/Origin.png)
서버의 위치를 의미하는 https://google.com과 같은 URL들은 마치 하나의 문자열 같아 보여도, 사실은 여러 개의 구성 요소로 이루어져있다.

이때 출처는 `Protocol`과 `Host`, 그리고 위 그림에는 나와있지 않지만 `:80`, `:443`과 같은 포트 번호까지 모두 합친 것을 의미한다. 즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은 것이다.

**또한 출처 내의 포트 번호는 생략이 가능한데, 이는 각 웹에서 사용하는 `HTTP`, `HTTPS` 프로토콜의 기본 포트 번호가 정해져있기 때문이다. (port 80)**

그러나 만약 https://google.com:443과 같이 출처에 포트 번호가 명시적으로 포함되어 있다면 **이 포트 번호까지 모두 일치해야 같은 출처라고 인정**된다.
하지만 이 케이스에 대한 명확한 정의가 표준으로 정해진 것은 아니기 때문에, 더 정확히 이야기하자면 **어떤 경우에는 같은 출처, 또 어떤 경우에는 다른 출처로 판단될 수도 있다.**

## Cross-Origin 판단 기준
이제 같은 출처와 다른 출처의 구분을 판단하는 법에 대해 알아보자.
두 개의 출처가 서로 같다고 판단하는 로직은, 두 URL의 구성 요소 중 Scheme(프로토콜), Host(도메인), Port, 이 3가지만 동일하면 된다.
![image](/image/Cross-Origin.png)

따라서 일반적으로는 **same-origin**이란 scheme(프로토콜), host(도메인), 포트가 같다는 말이며, 이 3가지 중 하나라도 다르면 **cross-origin**이다.

https://velog.io/@effirin/CORS%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

## CORS 정책은 언제 검사할까?
우리가 CORS 정책을 위반하는 리소스 요청을 하더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 로직을 가지고 있는 경우가 아니라면 **서버는 정상적으로 응답을 하고, 이후 브라우저가 이 응답을 분석해서 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않고 그냥 버리는 순서인 것이다.**

**서버는 CORS를 위반하더라도 정상적으로 응답을 해주고, 응답의 파기 여부는 브라우저가 결정한다.**
즉, ****CORS는 브라우저의 구현 스펙에 포함되는 정책**이기 때문에, 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않는다.
또한 **CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 남기 때문에**, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.